遗传算法实现:

  输入：教师信息，学生信息，教室信息，教学班信息
    ？：禁排信息
        优先级设置（学生所在院系优先、开课院系优先、按照课程性质优先、按照学时类型优先、按照课程类型优先等）
        启用班级固定教室
        教师每天、每周排课的最大节数，教师上午、下午的最大节次；
        体育课安排是否只能在下午，体育课后是否安排课程；
        学校晚上是否上课；
        实验课程是否只能安排在晚上；
        多学时（理论、实验、上机）类型的课程学时是否连续排；
        部分课程优先排课；
        

  常量：
    每天课程：8节

  额外适应判断标准：
    班级排课教室尽量集中、教师排课教室尽量集中，同一课程使用相同教室；
    排课的班级人数须小于教室的容量；


  额外考虑：
    周学时无法被连排节次整除时的安排方式（周学时为奇数，连排节次为偶数），参考：按单双周拆分、降低连排节次；
    自动排课时是否清除掉之前的已排信息；
    自动排课是是否需要安排地点；
    排课过程中对排课进行监控，总任务数、已完成任务数、未完成任务数；
    排课结果下载，对未排进去的课程进行未排原因输出。



遗传算法与贪心算法的结合
  核心思路：
    贪心算法的结果受列表中元素顺序的影响，元素的顺序可以使用遗传算法进行迭代优化。
    用遗传算法的输出（元素顺序）构建贪心算法的输入，最终结果由贪心算法构建，由贪心算法生成的结果更容易得到可行解。

  算法实现思路：
    遗传算法：
      输入：排课任务列表（从数据库获取）
      输出：排课任务列表（可能改变顺序）
      适应度计算（按重要程序排列）：
        使用贪心算法生成一个Schedule实例，判断其的：
          课程安排合法性（时间冲突、空间冲突、满足指定教室等硬性要求）
          课程安排优先级（来源task）
          同一班级的课程的教室集中程度
      变异：
        由于遗传参数为一个列表，而迭代对象为该列表的顺序，故采用以下方式
        选中一个随机课程任务，将其移动至列表中随机位置。
      交叉互换：
        为了保证每个任务在同一列表中的唯一性，同时保留交叉互换的思想，故采用以下方式
        对于两个配对的父代A和B
        随机选择[0,A.size())区间中的一个子区间L
        A产生的子代A'：
          复制A得到A1
          取B中索引在子区间L中的部分为B1
          将A1中索引在子区间L中的部分调整为与B1一致，得到A'
          伪代码实现例：
            List list=new List()
            int left=0;int right=0（分别指向A和list）
            for(;right<A.size();right++){
              if(right in L){
                list.add(B[right])
              }else{
                while(A[left] in B1) left++;
                list.add(A[left])
              }
            }
            return list;

    贪心算法：
      输入：教室列表、排课任务列表（从遗传算法获取）
      输出：一个Schedule实例，代表一个排课结果
    
    辅助类核心设计：
      排课任务列表抽象类：
        存储其使用贪心算法后生成的Schedule实例，防止重复计算
        更进一步地，可以将已计算过的排课任务列表进行存储，防止重复计算
      排课结果生成器：
        根据task中排课优先级生成初始种群的方法
        依赖于一个遗传算法抽象类
        维护一个最佳结果schedule，使用遗传算法产生
      遗传算法抽象类：
        结果列表List<Schedule>
        getBestSchedule()
        generateSchedule()
        依赖于一个贪心算法抽象类
      贪心算法抽象类：
        public static Schedule generateSchedule()